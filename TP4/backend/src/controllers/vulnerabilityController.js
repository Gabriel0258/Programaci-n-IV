const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { db } = require('../config/database');

// ===================================
//   Command Injection - Ping seguro
// ===================================

// Lista blanca de hosts permitidos
const allowedHosts = ['8.8.8.8', '1.1.1.1', 'google.com'];

const ping = (req, res) => {
  const { host } = req.body;

  if (!host || typeof host !== 'string') {
    return res.status(400).json({ error: 'Invalid host' });
  }

  const trimmed = host.trim();

  // Solo permitimos letras, números, puntos y guiones
  const hostRegex = /^[a-zA-Z0-9][a-zA-Z0-9.-]*$/;
  if (!hostRegex.test(trimmed)) {
    return res.status(400).json({ error: 'Invalid host' });
  }

  // Solo hosts de la lista blanca
  if (!allowedHosts.includes(trimmed)) {
    return res.status(400).json({ error: 'Invalid host' });
  }

  const args = ['-c', '1', trimmed]; // Linux/Mac (-c). En Windows sería '-n'

  const child = spawn('ping', args);

  let output = '';
  let errorOutput = '';

  child.stdout.on('data', (data) => {
    output += data.toString();
  });

  child.stderr.on('data', (data) => {
    errorOutput += data.toString();
  });

  child.on('error', () => {
    return res.status(500).json({ error: 'Error al ejecutar ping' });
  });

  child.on('close', (code) => {
    if (code !== 0) {
      return res.status(400).json({ error: 'Ping failed' });
    }

    return res.status(200).json({ output });
  });
};

// ===================================
//   CSRF – Obtener token
// ===================================

const getCsrfToken = (req, res) => {
  if (!req.session) {
    return res.status(500).json({ error: 'Sesión no inicializada' });
  }

  // Token aleatorio por sesión
  const token = crypto.randomBytes(32).toString('hex');
  req.session.csrfToken = token;

  // El test espera una cookie con SameSite=Strict
  res.cookie('csrfToken', token, {
    httpOnly: false,
    sameSite: 'Strict',
  });

  return res.status(200).json({ csrfToken: token });
};

// Lista blanca de orígenes permitidos
const allowedOrigins = ['http://localhost:3000'];

// ===================================
//   CSRF – Transferencia protegida
// ===================================

const transfer = (req, res) => {
  const { fromAccount, toAccount, amount } = req.body;

  // Debe haber usuario autenticado
  if (!req.session || !req.session.userId) {
    return res.status(401).json({ error: 'No autenticado' });
  }

  // Validar Origin/Referer
  const origin = req.get('origin') || req.get('referer');
  if (origin && !allowedOrigins.includes(origin)) {
    return res.status(403).json({ error: 'Invalid Origin' });
  }

  // Validar token CSRF
  const headerToken = req.get('x-csrf-token');
  const sessionToken = req.session.csrfToken;

  if (!headerToken || !sessionToken || headerToken !== sessionToken) {
    return res.status(403).json({ error: 'CSRF token inválido o ausente' });
  }

  // Si pasó todas las validaciones, hacemos la transferencia
  const query =
    'INSERT INTO transfers (from_account, to_account, amount, user_id) VALUES (?, ?, ?, ?)';
  db.query(query, [fromAccount, toAccount, amount, req.session.userId], (err) => {
    if (err) {
      return res.status(500).json({ error: 'Error en la transferencia' });
    }
    res.json({ message: 'Transferencia realizada con éxito' });
  });
};

// ===================================
//   Local File Inclusion
// ===================================

const readFile = (req, res) => {
  const { filename } = req.query;

  const filePath = path.join(__dirname, '../files', filename);

  fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      return res.status(404).json({ error: 'Archivo no encontrado' });
    }
    res.send(data);
  });
};

module.exports = {
  ping,
  getCsrfToken,
  transfer,
  readFile,
};
